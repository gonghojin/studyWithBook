# 6. 객체와 자료구조
변수를 private로 정의하는 이유는 남들이 변수에 의존하지 않게 만들어 변수 타입이나 구현을 제약없이 바꾸기 위해서다.    
그렇다면 어쨰서 수많은 프로그래머가 조회(get), 설정(set) 함수를 당연하게 공개(public)해 비공개 변수를 외부에 노출할까?...  

## 자료 추상화

###### 목록 6-1 구체적인 Point 클래스(구현을 외부로 노출)
~~~java
public class Point { 
  public double x; 
  public double y;
}
~~~

###### 목록 6-2 추상적인 Point 클래스(구현을 숨김)
~~~java
public interface Point {
  double getX();
  double getY();
  void setCartesian(double x, double y); 
  double getR();
  double getTheta();
  void setPolar(double r, double theta); 
}
~~~
목록 6-2는 구현을 숨기지만, 목록 6-1은 구현을 노출한다.  
변수를 private으로 선언하더라도 각 값마다 조회(get) 함수와 설정(set) 함수를 제공한다면 구현을 외부로 노출하는 셈이다.  
(변수 사이에 함수라는 계층을 넣는다고 구현이 저절로 감춰지지는 않는다.)  
`구현을 감추려면 추상화가 필요하다!!`  
조회, 설정 함수로 변수를 다룬다고 클래스가 되지는 않고 추상 인터페이스를 제공해 사용자가 구현을 모른 채 자료의 핵심을 조작할 수 있어야 진정한 의미의 클래스다.

###### 목록 6-3 구체적인 Vehicle  클래스
~~~java
// 자동차 연료 상태를 구체적인 숫자 값으로 알려줌(변수값을 읽어 본환할 뿐)
public interface Vehicle {
	double getFuelTankCapacityInGallons();
	dobule getGallonsOfGasoline();
}
~~~

###### 목록 6-4 추상적인 Vehicle 클래스
~~~java
// 백분율이라는 추상적인 개념으로 알려줌(정보 도출 과정 공개 x)
public interface Vehicle {
	double getPercentFuelRemaining();
}
~~~
+ Better
	+ 목록 6-2, 목록 6-4
		+ 자료를 세세하게 공개하기보다는 추상적인 개념으로 표현하는 편이 좋다.
		
+ worse
	+ 목록 6-1, 목록 6-3
		+ 인터페이스나 set,get만으로는 추상화가 이뤄지지 않는다.

> 개발자는 객체가 포함하는 자료를 표현할 가장 좋은 방법을 심각하게 고민해야 한다.  
> - 아무 생각없이 조회/설정 함수를 추가하는 방법이 가장 나쁘다.  

## 자료/객체 비대칭
앞서 소개한 두 가지 예제는 객체와 자료 구조 사이에 벌어진 차이를 보여준다.    
> 객체는 추상화 뒤로 `자료를 숨긴 채 자료를 다루는 함수만 공개한다`.   
> 자료 구조는 `자료를 그대로 공개하며` 별다른 함수는 제공하지 않는다.  

두 정의는 본질적으로 상반된다. 사소한 차이로 보일지 모르지만 그 차이가 미치는 영향은 굉장하다.  
###### 목록 6-5 절차적인 도형
```java
/*
	각 도형 클래는 간단한 자료구조다.
	- 아무 메서드도 제공하지 않는다.
	
	
 */
public class Square { 
  public Point topLeft; 
  public double side;
}

public class Rectangle { 
  public Point topLeft; 
  public double height; 
  public double width;
}

public class Circle { 
  public Point center; 
  public double radius;
}

public class Geometry {
  public final double PI = 3.141592653589793;
  
  public double area(Object shape) throws NoSuchShapeException {
    if (shape instanceof Square) { 
      Square s = (Square)shape; 
      return s.side * s.side;
    } else if (shape instanceof Rectangle) { 
      Rectangle r = (Rectangle)shape; 
      return r.height * r.width;
    } else if (shape instanceof Circle) {
      Circle c = (Circle)shape;
      return PI * c.radius * c.radius; 
    }
    throw new NoSuchShapeException(); 
  }
}
```
객체 지향 프로그래머가 위 코드를 본다면 코웃음을 칠지도 모르겠다. 클래스가 절차적이라 비판한다면 맞는 말이다.  
하지만 그런 비웃음이 100% 옳다고 말하기는 어렵다.   

만약 Geometry 클래스에 둘레 길이를 구하는 perimeter() 함수를 추가하고 싶다면?    
도형 클래스는 아무 영향도 받지 않는다! 도형 클래스에 의존하는 다른 클래스도 마찬가지다!  

반대로 새 도형을 추가하고 싶다면? 
Geometry 클래스에 속한 함수를 모두 고쳐야 한다. 