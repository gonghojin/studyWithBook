# 3. 함수
## 작게 만들어라!!
> 함수를 만드는 첫째 규칙은 `작게다.`  
> 함수는 명백해야하고 각 함수가 이야기 하나를 표현해야 한다. 
~~~java
public static String renderPageWithSetupsAndTeardowns( PageData pageData, boolean isSuite) throws Exception {
	boolean isTestPage = pageData.hasAttribute("Test"); 
	if (isTestPage) {
		WikiPage testPage = pageData.getWikiPage(); 
		StringBuffer newPageContent = new StringBuffer(); 
		includeSetupPages(testPage, newPageContent, isSuite); 
		newPageContent.append(pageData.getContent()); 
		includeTeardownPages(testPage, newPageContent, isSuite); 
		pageData.setContent(newPageContent.toString());
	}
	return pageData.getHtml(); 
}
~~~
리팩토링된 위 코드도 길다. 되도록 한 함수당 3 ~ 5줄 이내로 줄이는 것을 권장
~~~java
public static String renderPageWithSetupsAndTeardowns( PageData pageData, boolean isSuite) throws Exception { 
   if (isTestPage(pageData)) 
   	includeSetupAndTeardownPages(pageData, isSuite); 
   return pageData.getHtml();
}
~~~ 
#### 블록과 들여쓰기
if/else 문, while 문 등에 들어가는 블록은 한 줄이어야 한다.  
( 대게 거기서 함수를 호출한다. 그러면 바깥을 감싸는 함수(enclosing function가 작아진다.))  
함수에서 들여쓰기 수준은 1단이나 2단을 넘어서면 안 된다.  

## 한 가지만 해라!!
> 함수는 한 가지를 해야 한다. 그 한 가지를 잘 해야 한다. 그 한 가지만을 해야 한다.  
> + 지정된 함수 이름 아래에서 `추상화 수준이 하나인 단계만 수행`한다면 그 함수는 한 가지 작업만 한다.  
>
> 함수가 '한 가지'만 하는 지 판단하는 방법
> + 단순히 다른 표현이 아니라 `의미있는 이름으로 다른 함수`를 추출할 수 있다면, 그 함수는 여러 작업을 하는 셈이다.  

## 함수 당 추상화 수준은 하나로!  
함수가 확실히 '한 가지' 작업만 하려면 `함수 내 모든 문장의 추상화 수준이 동일`해야 한다.  
한 함수 내에 추상화 수준을 섞으면 코드를 읽는 사람이 헷갈린다.  
(특정 표현이 근본 개념인지 아니면 세부사항인지 구분하기 어려운 탓)  

#### 위에서 아래로 코드 읽기: `내려가기` 규칙  
코드는 위에서 아래로 이야기처럼 읽혀야 좋다.   
한 함수 다음에는 추상화 수준이 한 단계 낮은 함수가 온다.  
(즉, 위에서 아래로 프로그램을 읽으면 함수 추상화 수준이 한 번에 한 단계씩 낮아진다. - 내려가기 규칙)  

## Switch문  
~~~java
public Money calculatePay(Employee e) throws InvalidEmployeeType {
	switch (e.type) { 
		case COMMISSIONED:
			return calculateCommissionedPay(e); 
		case HOURLY:
			return calculateHourlyPay(e); 
		case SALARIED:
			return calculateSalariedPay(e); 
		default:
			throw new InvalidEmployeeType(e.type); 
	}
}
// 문제점 
// 1: 함수가 길다.
//  - 새 직원 추가 시 더 길어짐
// 2: '한 가지' 작업만 수행하지 않는다.
// 3: Single Responsibility Principle 위반(SRP)
//  - 코드를 변경할 이유가 여럿
// 4: Open / Closed Principle 위반
//  - 새 직원을 추가할 때마다 코드 변경 필요
~~~
Switch 문은 작게 만들기 어렵지만, `다형적 객체를 생성하는 코드 안에서만 사용하도록 한다.`  
하지만 switch 문은 불가피하게 써야될 상황이 많으므로, 상황에 따라서는 사용 할 수도 있다.
~~~java
public abstract class Employee {
	public abstract boolean isPayday();
	public abstract Money calculatePay();
	public abstract void deliverPay(Money pay);
}
-----------------
public interface EmployeeFactory {
	public Employee makeEmployee(EmployeeRecord r) throws InvalidEmployeeType; 
}
-----------------
public class EmployeeFactoryImpl implements EmployeeFactory {
	public Employee makeEmployee(EmployeeRecord r) throws InvalidEmployeeType {
		switch (r.type) {
			case COMMISSIONED:
				return new CommissionedEmployee(r) ;
			case HOURLY:
				return new HourlyEmployee(r);
			case SALARIED:
				return new SalariedEmploye(r);
			default:
				throw new InvalidEmployeeType(r.type);
		} 
	
}
~~~