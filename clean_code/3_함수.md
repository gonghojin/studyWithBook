# 3. 함수
## 작게 만들어라!!
> 함수를 만드는 첫째 규칙은 `작게다.`  
> 함수는 명백해야하고 각 함수가 이야기 하나를 표현해야 한다. 
~~~java
public static String renderPageWithSetupsAndTeardowns( PageData pageData, boolean isSuite) throws Exception {
	boolean isTestPage = pageData.hasAttribute("Test"); 
	if (isTestPage) {
		WikiPage testPage = pageData.getWikiPage(); 
		StringBuffer newPageContent = new StringBuffer(); 
		includeSetupPages(testPage, newPageContent, isSuite); 
		newPageContent.append(pageData.getContent()); 
		includeTeardownPages(testPage, newPageContent, isSuite); 
		pageData.setContent(newPageContent.toString());
	}
	return pageData.getHtml(); 
}
~~~
리팩토링된 위 코드도 길다. 되도록 한 함수당 3 ~ 5줄 이내로 줄이는 것을 권장
~~~java
public static String renderPageWithSetupsAndTeardowns( PageData pageData, boolean isSuite) throws Exception { 
   if (isTestPage(pageData)) 
   	includeSetupAndTeardownPages(pageData, isSuite); 
   return pageData.getHtml();
}
~~~ 
#### 블록과 들여쓰기
if/else 문, while 문 등에 들어가는 블록은 한 줄이어야 한다.  
( 대게 거기서 함수를 호출한다. 그러면 바깥을 감싸는 함수(enclosing function가 작아진다.))  
함수에서 들여쓰기 수준은 1단이나 2단을 넘어서면 안 된다.  

## 한 가지만 해라!!
> 함수는 한 가지를 해야 한다. 그 한 가지를 잘 해야 한다. 그 한 가지만을 해야 한다.  
> + 지정된 함수 이름 아래에서 `추상화 수준이 하나인 단계만 수행`한다면 그 함수는 한 가지 작업만 한다.  
>
> 함수가 '한 가지'만 하는 지 판단하는 방법
> + 단순히 다른 표현이 아니라 `의미있는 이름으로 다른 함수`를 추출할 수 있다면, 그 함수는 여러 작업을 하는 셈이다.  

## 함수 당 추상화 수준은 하나로!  
함수가 확실히 '한 가지' 작업만 하려면 `함수 내 모든 문장의 추상화 수준이 동일`해야 한다.  
한 함수 내에 추상화 수준을 섞으면 코드를 읽는 사람이 헷갈린다.  
(특정 표현이 근본 개념인지 아니면 세부사항인지 구분하기 어려운 탓)  

#### 위에서 아래로 코드 읽기: `내려가기` 규칙  
코드는 위에서 아래로 이야기처럼 읽혀야 좋다.   
한 함수 다음에는 추상화 수준이 한 단계 낮은 함수가 온다.  
(즉, 위에서 아래로 프로그램을 읽으면 함수 추상화 수준이 한 번에 한 단계씩 낮아진다. - 내려가기 규칙)  

## Switch문  
~~~java
public Money calculatePay(Employee e) throws InvalidEmployeeType {
	switch (e.type) { 
		case COMMISSIONED:
			return calculateCommissionedPay(e); 
		case HOURLY:
			return calculateHourlyPay(e); 
		case SALARIED:
			return calculateSalariedPay(e); 
		default:
			throw new InvalidEmployeeType(e.type); 
	}
}
// 문제점 
// 1: 함수가 길다.
//  - 새 직원 추가 시 더 길어짐
// 2: '한 가지' 작업만 수행하지 않는다.
// 3: Single Responsibility Principle 위반(SRP)
//  - 코드를 변경할 이유가 여럿
// 4: Open / Closed Principle 위반
//  - 새 직원을 추가할 때마다 코드 변경 필요
~~~
Switch 문은 작게 만들기 어렵지만, `다형적 객체를 생성하는 코드 안에서만 사용하도록 한다.`  
하지만 switch 문은 불가피하게 써야될 상황이 많으므로, 상황에 따라서는 사용 할 수도 있다.
~~~java
public abstract class Employee {
	public abstract boolean isPayday();
	public abstract Money calculatePay();
	public abstract void deliverPay(Money pay);
}
-----------------
public interface EmployeeFactory {
	public Employee makeEmployee(EmployeeRecord r) throws InvalidEmployeeType; 
}
-----------------
public class EmployeeFactoryImpl implements EmployeeFactory {
	public Employee makeEmployee(EmployeeRecord r) throws InvalidEmployeeType {
		switch (r.type) {
			case COMMISSIONED:
				return new CommissionedEmployee(r) ;
			case HOURLY:
				return new HourlyEmployee(r);
			case SALARIED:
				return new SalariedEmploye(r);
			default:
				throw new InvalidEmployeeType(r.type);
		} 
	
}
~~~

## 서술적인 이름을 사용하라!
+ 함수 이름이 길어질지라도 `함수가 하는 일을 좀 더 잘표현하는 함수명이 훨씬 좋은 이름이다.`  
+ 코드를 읽으면서 `짐작했던 기능을 그대로 수행한다면` 깨끗한 코드이다.  
+ 함수가 작고 단순할수록 서술적인 이름을 고르기도 싶다.

> 좋은 함수 이름 정하기  
> 1. 함수 이름을 정할 떄는 여러 단어가 쉽게 읽히는 명명법을 사용한다.
> 2. 여러 단어를 사용해 함수 기능을 잘 표현하는 이름을 선택한다.  
> 3. 이름을 붙일 때는 일관성이 있어야 한다. 모듈 내에서 함수 이름은 같은 문구, 명사, 동사를 사용한다.  
>   + 좋은 예)  
        includeSetupAndTeardownPages, includeSetupPages  
        , includeSuiteSetupPage, includeSetupPage 등  

> 서술적인 이름의 부가적인 장점    
> 개발자 머릿 속에서도 설계가 뚜렷해지므로, 코드를 개선하기 쉬워진다.  

## 함수 인수  
> 함수에서 이상적인 인수 개수는 0개(무항)다. 인수는 적을수록 좋고 3개(삼항) 이상은 가능하면 피하는 편이 좋다.  
>(인수는 개념을 이해하기 어렵게 만들기 때문에 최소한으로 사용)  
>+ includeSetupPageInto(new PageContent)보다 includeSetupPage()가 이해하기 쉬움  

> 출력인수를 사용하지 말자  
> (대개 함수에다 인수로 입력을 넘기고 반환값으로 출력을 받기 떄문에 혼동을 줄 수 있다.) 

### 많이 쓰는 단항 형식
+ 인수에 질문을 던지는 경우
    + boolean fileExists("MyFile")
+ 인수를 뭔가로 변환해 결과를 반환하는 경우
    + Inpustream fileOpen("MyFile")
+ 이벤트 함수
    + 이벤트라는 사실이 코드에 명확이 드러나야 한다.  

위의 3 가지가 아니라면 가급적 단항함수는 피한다.  

