## Concurrency(동시성)
> 객체는 처리의 추상화다. 스레드는 일정의 추상화다.  

Concurrency(동시성)과 깔끔한 코드는 양립하기 어렵다. 아주 어렵다. 스레드를 하나만 실행하는 코드는 짜기가 쉽다. 겉으로 보기에는 멀쩡하나 깊숙한 곳에 문제가 있는 다중 스레드 코드도 짜기 쉽다.  
이런 코드는 시스템이 부하를 받기 전까지 멀쩡하게 돌아간다. 

###### 이 장에 다를 내용
+ 여러 스레드를 동시에 돌리는 이유
+ 여러 스레드를 동시에 돌리는 어려움
	+ 이런 어려움에 대처하고 꺠끗한 코드를 작성하는 방법도 몇 가지 제안한다.
+ Concurrency(동시성)을 테스트하는 방법과 문제점

깨끗한 Concurrency(동시성)은 책 하나를 할당할 정도로 복잡한 주제다. 이 장에서는 Concurrency(동시성)을 간략히 조감한다.(Concurrency(동시성)이 무엇인지 궁금한 정도만 채워준다...)  

## Concurrency(동시성)이 필요한 이유?
Concurrency(동시성)은 결합(coupling)을 없애는 전략이다.
> 즉, `무엇(what)`과 `언제(when)`를 분리하는 전략이다.   

스레드가 하나인 프로그램은 `무엇과 언제가 서로 밀접하다.` 그래서 호출 스택을 살펴보면 프로그램 상태가 곧바로 드러난다.  
흔히 단일 스레드 프로그램을 디버깅하는 프로그래머는 (일련의) 정지점(break point)을 정한 후 어느 정지점에 걸렸는지 살펴보면서 시스템 상태를 파악한다.

`무엇`과 `언제`를 분리하면 애플리케이션 구조와 효율이 극적으로 나아진다. 구조적인 관점에서 프로그램은 거대한 루프 하나가 아니라 작은 협력 프로그램 여럿으로 보인다. 따라서 시스템을 이해하기가 쉽고 문제를 분리하기도 쉽다.  
예를들어, 웹 애플리케이션이 표준으로 사용하는 '서블릿(Servlet) 모델'을 살펴보자.  
서블릿은 웹 혹은 EJB 컨테이너라는 우산 아래서 돌아가는데, 이들 컨테이너는 Concurrency(동시성)을 `부분적`으로 관리한다.  
웹 요청이 들어올 때마다 웹 서버는 비동기식으로 서블릿을 실행한다. 서블릿 프로그래머는 들어오는 모든 웹 요청을 관리할 필요가 없다. `원칙적`으로 각 서블릿 스레드는 다른 서블릿 스레드와 무관하게 자신만의 세상에서 돌아간다.  
  
구조적 개선만을 위해 Concurrency(동시성)을 채택하는 건 아니다. 어떤 시스템은 응답 시간과 작업 처리량(throughput) 개선이라는 요구사항으로 인해 직접적인 Concurrency(동시성) 구현이 불가피하다.  
~~~
예를 들어, 매일 수많은 웹 사이트에서 정보를 가져와 요약하는 정보 수집기를 생각해보자.
만약 수집기가 단일 스레드 프로그램이라면 한 번에 한 웹사이트를 방문해 정보를 가져오며, 이 과정에서 한 사이트를 끝내야 다음 사이트로 넘어간다.
매일 실행하므로 24시간 안에 끝나야 한다. 그런데 웹 사이트를 계속 추가하면 정보를 수집하는 시간도 늘어나므로 결국은 24시간을 넘긴다.
한 번에 한 사이트를 방문하는 대신 다중 스레드 알고리즘을 이용하면 수집기 성능을 높일 수 있다.
~~~