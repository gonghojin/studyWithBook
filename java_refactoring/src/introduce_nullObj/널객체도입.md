## 리팩토링 카탈로그 4 (널 객체 도입)
+ 이름
	+ 널 객체 도입  
+ 상황 
	+ 객체를 다룸
+ 문제
	+ null 확인이 너무 많음
+ 해법
	+ null을 나타내는 특별한 객체를 도입해 '아무것도 안 함'이라는 처리를 함
+ 결과
	+ null 확인이 줆어듦
	+ 널 객체만큼 클래스가 늘어남
+ 방법
	1. 널 객체 클래스 작성
		1. 기존 클래스(null을 확인하는 클래스)의 하위 클래스로 작성
		2. isNull 메서드 작성
			+ 기존 클래스는 false 반환
			+ 널 객체 클래스는 true 반환
		3. 컴파일
	2. null 치환하기
		1. null을 널 객체로 치환
		2. null 확인을 isNull 메서드 호출로 치환
		3. 컴파일해서 테스트
	3. 널 객체 클래스를 재정의해서 조건 판단 삭제하기
		1. isNull 메서드를 사용하는 조건 판단에서 다음과 같은 코드를 찾기
			~~~
			if (obj.isnull()) {
				<null 동작>
			} else {
				obj.doSomething();
			}
			~~~
		2. 널 객체 클래스에서 doSomething 메서드를 오버라이드함. 이 메서드에서 null 동작을 작성함
		3. 조건 판단 삭제  
			~~~
			obj.doSomething();
			~~~
		4. 컴파일해서 테스트
+ 관련 항목
	+ 어서션 도입
		+ 잘못해서 null을 사용하고 있지 않은지 확인하기 위한 어서션을 도입하면 좋음
	+ 널 객체 패턴
	+ 싱글톤 패턴
	+ 팩토리 메서드 패턴
	

### 한 걸음 더 나아가기
1. 팩토리 메서드 패턴
	+ new NullLabel() -> Label.newNull()
	~~~java
	public static Label newNull() {
		return new NullLabel();
	}
	~~~
2. 싱글톤 패턴
	+ 널 객체가 필요할 때마다 new NullLabel()로 인스턴스를 작성하는 건 시간과 메모리 낭비이다.  
	원래 널 객체는 아무것도 안 하니깐 상태를 유지할(필드를 가질) 필요가 거의 없다.  
	따라서 `싱글턴 패턴`으로 실제 인스턴스를 하나로 줄이는 게 더 낫다.
		+ newNull()이 반환하는 인스턴스는 늘 동일하게 된다.
3. 널 객체로 중첩 클래스 사용
	+ 널 객체를 도입을 하면 null 확인이 줄어드는 대신에 클래스 개수가 늘어난다.  
	`널 객체 클래스를 원래 클래스의 중첩 클래스(클래스 안에 선언한 클래스)`로 구현하면 클래스 개수는 줄지 않지만, 코드를 깔끔하게 정리할 수 있고 클래스 관리가 수월해진다.  
	~~~java
	public class Label {
		...
		private static class NullLabel extends Label {
			...
		}
	}
	~~~
	
###### 팩토리 메서드 패턴, 실글톤 패턴, 중첩 클래스로 작성한 Label 클래스	  
~~~java
public 
~~~