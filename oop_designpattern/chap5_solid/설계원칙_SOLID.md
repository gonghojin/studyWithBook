## 설계 원칙 : SOLID
객체 지향적으로 설계하는데 기본이 되는 설계원칙 : SOLID  
+ 단일 책임 원칙 (Single responsibility principle : SRP)
+ 개방 - 폐쇄 원칙 (Open - closed principle : OCP)
+ 리스코프 치환 원칙 (Liskov substitution principle : LSP)
+ 인터페이스 분리 원칙 (Interface segregation principle : ISP)
+ 의존 역전 원칙 (Dependency invenstion principle : DIP)
##

### 1. 단일 책임 원칙 (SRP)
객체 지향의 기본은 책임을 객체에게 할당하는 데 있다. 객체를 객체로 존재하게 하는 이유가 책임인데, 단일 책임 원칙(SRP)는 이 책임과 관련된 원칙이다.  
 + 클래스는 단 한 개의 책임을 가져야 한다.  

클래스가 여러 책임을 갖게 되면 그 클래스는 각 책임마다 변경되는 이유가 발생하기 때문에, 클래스가 한 개의 이유로만 변경되려면 클래스는 한 개의 책임만을 가져야 한다.  
이런 이유로 이 원칙은 다른 말로 "클래스를 변경하는 이유는 단 한개여야 한다."고도 표현한다.  

**단일 책임 원칙이 잘 지켜지지 않으면 다른 원칙들도 그 효과가 반감되기 때문에 최대한 지켜야하는 원칙이 바로 '단일 책임 원칙'이다.**

#### 1.1 단일 책임 원칙 위반이 불러오는 문제점
책임의 개수가 많아질 수록 한 책임의 기능 변화가  다른 책임에 주는 영향은 비례해서 증가하게 되는데, 이는 결국 코드를 절차 지향적으로 만들어 변경을 어렵게 만든다.

한 클래스에 섞여 있던 책임을 두 클래스로 분리함으로써 변경의 여파를 줄일 수 있게 되는 것이다.

단일 책임 원칙을 어길 떄 발생하는 또 다른 문제점은 재사용을 어렵게 한다는 것이다.

#### 1.2 책임이란 변화에 대한 것
기능 변경 요구가 없을 때 수정에 대한 문제가 없다는 것은, 뒤집어 보면 책임의 단위는 변화되는 부분과 관련된다는 의미가 된다.

서로 다른 이유로 바뀌는 책임들이 한 클래스에 함게 포함되어 있다면, 이 클래스는 단일 책임 원칙을 어기고 있다고 볼 수 있다.

어떻게 하면 단일 책임 원칙을 지킬 수 있을까? - 그 방법은 바로 **메서드를 실행하는 것이 누구인지 확인해 보는 것이다.**

클래스의 사용자들이 서로 다른 메서드들을 사용한다면 그들 메서드는 각각 다른 책임에 속할 가능성이 높고, 따라서 책임 분리 후보가 될 수 있다.
##
### 2. 개방 폐쇄 원칙 (OCP)
+ 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 한다. **즉 , 기능을 변경하거나 확장할 수 있으면서, 그 기능을 사용하는 코드는 수정하지 않는다.**

개방 폐쇄 원칙을 구현할 수 있는 이유는 확장되는 부분(즉, 변화되는 부분)을 추상화해서 표현했기 때문이다.

개방 폐쇄 원칙을 구현하는 또 다른 방법은 **상속**을 이용하는 것이다.  
상속은 상위 클래스의 기능을 그대로 사용하면서 하위 클래스에서 일부 구현을 오버라이딩할 수 있는 방법을 제공한다.

#### 2.1 개방 폐쇄 원칙이 꺠질 떄의 주요 증상
추상화와 다형성을 이용해서 개방 폐쇄 원칙을 구현하기 때문에, 추상화와 다형성이 제대로 지켜지지 않은 코드는 개방 폐쇄 원칙을 어기게 된다.  
개방 폐쇄 원칙을 어기는 코드의 전형적인 특징은 다음과 같다.
+ 다운 캐스팅을 한다.
+ 비슷한 if-else 블록이 존재한다.

#### 2.2 개방 폐쇄 원칙은 유연함에 대한 것
걔방 폐쇄 원칙은 변경의 유연함과 관련된 원칙이다. 개방 폐쇄 원칙은 변화되는 부분을 추상화함으로써 사용자 입장에서 변화를 고정시킨다.  

개방 폐쇄 원칙은 변화가 예상되는 것을 추상화해서 변경의 유연함을 얻도록 해준다. 이 말은 변화되는 부분을 추상화하지 못하면(또는 안 하면) 개방 폐쇄 원칙을 지킬 수 없게 되어 시간이 흐를수록 기능 변경이나 확장을 어렵게 만든다는 것을 뜻한다.  
**따라서 코드에 대한 변화 요구가 발생하면, 변화와 관련된 구현을 추상화해서 개방 폐쇄 원칙에 맞게 수정할 수 있는지 확인하는 습관을 갖도록하자.**
