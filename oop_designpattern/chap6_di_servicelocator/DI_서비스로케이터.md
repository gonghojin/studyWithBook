## DI(Dependency Injection)와 서비스 로케이터
로버트 C마틴은 소프트 웨어를 두개의 영억으로 구분해서 설명하고 있는데, 한 영역은 고수준 정책 및 저수준 구현을 포함한 어플리케이션 영역이고 또 다른 영역은 어플리케이션이 동작하도록 각 객체들을 연결해 주는 메인 영역이다.  
메인 영역에서 객체를 연결하기 위해 사용되는 방법인 DI와 서비스 로케이터에 대해 알아보자.  
##
### 1. 어플리케이션 영역과 메인 영역  
메인 영역은 다음 작업을 수행한다.  
+ 어플리케이션 영역에서 사용될 객체를 생성한다.  
+ 각 객체 간의 의존관계를 설정한다.  
+ 어플리케이션을 실핸한다.  
  
Main 클래스의 main() 메서드는 어플리케이션을 실행하는데 필요한 저수준 모듈 객체를 먼저 생성하고, Locator를 설정한다.  
메인 영역은 어플리케이션 영역의 객체를 생성하고, 설정하고, 실행하는 책임을 갖기 때문에, 어플리케이션 영역에서 사용할 하위 수준의 모듈을 변경하고 싶다면 메인 영역을 수정하게 된다.  
따라서 모든 의존은 메인 영역에서 어플리케이션 영역으로 향한다.(반대의 경우인 어플리케이션 영역에서 메인영역으로의 의존은 존재하지 않는다.)  
이는 메인 영역을 변경한다고 해도 어플리케이션 영역은 변경되지 않는다는 것을 뜻한다. 따라서 어플리케이션에서 사용할 객체를 교체하기 위해 메인 영역의 코드를 수정하는 것은 어플리케이션 영역에는 어떠한 영향도 끼치지 않는다.  

서비스 로케이터 : 사용할 객체를 제공하는 책임을 갖는 객체  
서비스 로케이터 방식은 로케이터를 통해서 필요로 하는 객체를 직접 찾는 방식인데, 이 방식에는 몇 가지 단점이 존재한다.  
그래서 서비스 로케이터를 사용하기보다는 외부에서 사용할 책체를 주입해 주는 DI 방식을 사용하는 것이 일반적이다. [그래서 스프링의 DI를 그리 강조했구나..] 
##
### 2. DI을 이용한 의존 객체 사용
콘크리트 클래스를 직접 사용해서 객체를 생성하게 되면 **의존 역전 원칙**을 위반하게 되며, 결과적으로 확장 폐쇄 원칙을 위반하게 된다. SOLID 원칙에서 설명했듯이 이는 변화에 경직된 유연하지 못한 코드를 만들게 된다.  
이런 단점을 보완하기 위한 방법이 DI(의존성 주입)이다. DI는 필요한 객체를 직접 생성하거나 찾지 않고 외부에서 넣어주는 방식이다.  
DI를 통해서 의존 객체를 관리할 떄에는 객체를 생성하고 각 객체들을 의존 관계에 따라 연결해주는 조립 기능이 필요하다(스프링 컨테이너)  
#### 2.1 생성자 방식과 설정 메서드 방식
DI를 적용하려면 의존하는 객체를 전달받을 수 있는 방법을 제공해야 하는데, 이 방법에는 크게 다음의 두 가지 방식이 존재한다.  
+ 생성자 방식 
+ 설정 메서드 방식  
설정 메서드를 어떻게 구현할지 여부(자바빈 규약, 한 개의 메서드에 의존 객체 모두 설정, 메서드 체이닝 - p149)는 사용할 DI 프레임워크에 따라 달라질 수 있다.  

**각 방식의 장단점**
~~~
<생성자 방식>
객체를 생성하는 시점에, 필요한 모든 의존 객체를 준비할 수 있다. 따라서 객체를 생성하는 시점에서 의존 객체가 정상인지 확인할 수 있다.  
따라서 생성 시점에 의존 객체를 모두 받기 때문에, 한번 객체가 생성되면 객체가 정상적으로 동작함을 보장할 수 있다.
(설정 메서드 방식은 객체를 생성한 뒤에 의존 객체를 주입하게 된다. 이 경우 의존 객체를 설정하지 못한 상태에서 객체를 사용할 수 있음)

생성자 방식을 사용하려면 의존 객체가 먼저 생성되어 있어야 하므로, 의존 객체를 먼저 생성할 수 없다면 생성자 방식을 사용할 수없게 된다.

<설정 메서드 방식>
객체를 생성한 이후에 의존 객체를 설정할 수 있기 때문에, 어떤 이유로 인해 의존할 객체가 나중에 생성된다면 설정 메서드 방식을 사용해야 한다.  
또 의존할 객체가 많을 경우, 설정 메서드 방식은 메서드 이름을 통해서 어떤 의존 객체가 설정되는지 (생성자 방식에 비해)보 보다 쉽게 알 수 있으며, 이는 코드 가독성을 높여주는 효과가 있다. 
~~~

#### 2.2 DI와 테스트
단위 테스트는 한 클래스의 기능을 테스트하는데 초점을 맞춘다. 
DI는 의존 객체를 fMock 객체로 쉽게 대체할 수 있도록 함으로써 단위 테스트를 할 수 있도록 돕는다.
##
### 3. 서비스 로케이터를 이용한 의존 객체 사용
프로그램 개발 환경이나 사용하는 프레임워크의 제약으로 인해 DI 패턴을 적용할 수 없는 경우가 있다. 따라서 DI패턴을 적용할 수 없는 경우에는 의존 객체를 찾는 다른 방법을 모색해야 하는데, 그 방법 중 하나가 **서비스 로케이터**이다.
#### 3.1 서비스 로케이터의 구현
서비스 로케이터는 어플리케이션에서 필요로 하는 객체를 제공하는 책임을 갖는다. 서비스 로케이터가 올바르게 동작하려면 서비스 로케이터 스스로 어떤 객체를 제공해야 할지를 알아야 한다.  
서비스 로케이터는 어플리케이션 영역의 객체에서 직접 접근하기 떄문에 어플리케이션 영역에 위치하게 된다.  
메인 영역에서는 서비스 로케이터가 제공할 객체를 생성하고, 이 객체를 이용해서 서비스 로케이터를 초기화 해준다.  

서비스 로케이터를 구현하는 방법
+ 객체 등록 방식의 구현 방법
+ 상속을 통한 구현 방법  
~~~
<객체 등록 방식의 서비스 로케이터 구현>
서비스 로케이터를 구현하는 가장 손쉬운 방법은
1. 서비스 로케이터를 생성할 때 사용할 객체를 전달한다.
2. 서비스 로케이터 인스턴스를 지정하고 참조하기 위한 static 메서드를 제공한다.

객체를 등록하는 방식의 장점은 서비스 로케이터 구현이 쉽다는 데 있다. 하지만, 서비스 로케이터에 객체를 등록하는 인터페이스가 노출되어 있기 떄문에 어플리케이션 영역에서 얼마든지 의존 객체를 바꿀 수 있다.
서비스 로케이터에 등록된 객체를 변경할 수 있게 되면 고수준 모듈에서 콘크리트 클래스에 직접 접근하도록 유도할 수 있기 때문에 이는 의존 역전 원칙을 어기게 만드는 원인이 된다.
~~~
~~~
<상속을 통한 서비스 로케이터 구현>
1. 객체를 구하는 추상 메서드를 제공하는 상위 타입 구현
2. 상위 타입을 상속받은 하위 타입에서 사용할 객체 설정
~~~
~~~
<제네릭/템플릿을 이용한 서비스 로케이터 구현>
 서비스 로케이터의 단점은 인터페이스 분리 원칙을 위반한다는 점이다. 이 문제를 해결하려면 의존 객체마다 의존 객체마다 서비스 로케이터를 작성해 주어야 하지만 동일한 구조의 서비스 로케이터 클래스틑 중복해서 만드는 문제를 야기할 수 있다.  
 이런 중복된 코드를 작성하는 것은 무조건 피애햐 하는데, 이떄 제네릭(자바)이나 템플릿(C++)을 이용하면 중복된 코드를 피하면서 인터페이스를 분리한 것과 같은 효과를 낼 수 있다.
~~~
#### 3.2 서비스 로케이터의 단점
서비스 로케이터의 가장 큰 단점은 동일 타입의 객체가 다수 필요한 경우, 각 객체 별로 제공 메서드를 만들어 주어야 한다는 점이다.  
또한 인터페이스 분리 원칙을 위배한다는 점이다. 이렇듯 서비스 로케이터는 DI에 변경의 유연함을 떨어뜨리는 문제를 갖고 있기 떄문에, **부득이한 상황이 아니라면 서비스 로케이터보다는 DI를 사용하자.**