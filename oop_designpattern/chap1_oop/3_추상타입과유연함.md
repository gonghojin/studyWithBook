#### 1.기존

 ````
 public class FlowController {  
      
      public void process() {
        FileDataReader reader = new FileDataReader();
        byte[] data = reader.read();
        
        Encryptor encryptor = new Encryptor();
        byte[] encryptedData = new encryptor.encrypt(data);
        
        FileDataWriter writer = new FileDataWriter();
        writer.write(encryptedData);
    }
} 
````




#### 2.조건에 따라 데이터 읽는 형식을 변경해 달라고 요청이 올 때

````
public class FlowController {  
    
    private boolean useFile;
    
    public FlowController(boolean useFile) {
        this.useFile = useFile;
    }
    public void process() {
        byte[] data = null;
        **if (useFile) { 
           FileDataReader fileReader = new FileDataReader();
            data = fileReader.read();
        } else {
            SocketDataReader socketReader = new SocketDataReader();
        }**
        
        Encryptor encryptor = new Encryptor();
        byte[] encryptedData = new encryptor.encrypt(data);
        
        FileDataWriter writer = new FileDataWriter();
        writer.write(encryptedData);
    }
}
````

#### 3. 데이터를 읽는 형식이 많아질 경우
데이터를 읽어오는 방식이 많아지면 2번의 과정으로는 if의 블럭이 많아진다. 해결이 필요하다.  
위 과정의 공통점은 있다. 바로 **읽기**이다. 이는 두 개의 상세 구현을 동일한 개념으로 추상화 할 수 있는 것을 의미한다.  
+ 어떤 곳으로부터 바이트 데이터 일기
````
public interface ByteSource {
    public byte[] read();
}
````
````
public class FileDataReader implements ByteSource {
    public byte[] read() {
        ...
    }
}

public class SocketDataReader implements ByteSource {
    ...
}
````
+ 다형성으로 인한 FlowControlelr의 간소화
````
    ByteSource source = null;
    if (useFile) {
        source = new FileDataReader();
    } else {
        source = new SocketDataReader();
    }
    byte [] data = source.read();
````
하지만 증가하는 데이터 읽기 방식에 따른 if문 증가는 보완하지 못함.  

**보완할 방법 두 가지**
+ 방법 1:  객체를 생성하는 기능을 별도로 분리
````
    public class ByteSourceFactory {
        public ByteSouce create() { // 객체 생성 기능을 위한 오퍼레이션 정의
            if (useFile()) {
            
            }
        }  
        
        private boolean useFile() {
            String useFileVal = System.getProperty("useFile");

            return useFileVal != null && Boolean.valueOf(useFileVal);
        }
        
        // 싱글톤 패턴 적용
        private static ByteSourceFactory instance = new ByteSourceFactory();
        public static ByteSourceFactory getInstance() {
            return instance;
        }
        
        private ByteSourceFactory() {}
    }
````
````
    public void process() {
        ByteSource source = ByteSourceFactory.getInstance().create();
        byte[] data = source.read();
        
        ...
    }
````