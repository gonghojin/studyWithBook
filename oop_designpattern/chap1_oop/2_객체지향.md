## 객체 지향
객체 지향을 잘 하려면  이와 대조되는 개법인 절차 지향적으로 프로그램을 작성하면 안된다. 객체 지향을 지원하는 언어를 사용하더라도 실제 결과물은 객체 지향과 거리가 멀어질 수 있다.  
이런 결과가 나오는 이유는 객체 자체와 객체 지향의 핵심인 *캡슐화 및 추상화가 적용되지 않았기 때문이다.*  
##
### 1. 절차 지향과 객체 지향
#### 1.1 절차지향  
데이터를 조작하는 코드를 별도로 분리해서 함수나 프로시저와 같은 형태로 만들고, 각 프로시저들이 데이터를 조작하는 방식으로 코드를 작성할 수 있을 것이다.  
프로시저는 다른 프로시저를 사용할 수도 있고, 각각의 프로시저가 같은 데이터를 사용할 수 있다.  
*이렇게 프로시저로 프로그램을 구성하는 기법을 절차지향 프로그래밍이라고 부른다.*  
#### 1.2 객체 지향
절차 지향과 달리 *객체 지향은 데이터 및 데이터와 관련된 프로시저를 객체라고 불리는 단위로 묶는다.*  
객체는 프로시저를 실행하는데 필요한 만큼의 데이터를 가지며, 객체들이 모여 프로그램을 구성한다.  
모든 프로시저가 데이터를 공휴하는 절차 지향과 달리 *객체 지향은 객체 별로 데이터와 프로시저를 알맞게 정의해야 한다.*  
##
### 2. 객체
#### 2.1 객체의 핵심은 기능을 제공하는 것  
객체 지향의 가장 기본은 객체다. 앞서 객체는 데이터와 그 데이터를 조작하는 프로시저(오퍼레이션, 메서드, 함수로)로  구성된다고 했는데, 이는 객체의 물리적인 특징일 뿐이다.  
실제로 객체를 정의할 때 사용되는 것은 *객체가 제공해야할 기능이며, 객체가 내부적으로 어떤 데이터를 갖고 있는 지로는 정의되지 않는다.*  
#### 2.2 인터페이스와 클래스  
객체는 객체가 제공하는 기능으로 정의된다고 했는데, 보통 객체가 제공하는 기능을 *오퍼레이션*이라고 부른다. *즉, 객체는 오퍼세이션으로 정의가 된다.*  
오퍼레이션의 사용법은 일반적으로 다음과 같이 세개로 구성되며, 이 세 가지를 합쳐서 *시그니처*라고 부른다
+ 기능 식별 이름
+ 파라미터 및 파티미터 타입
+ 기능 실행 결과 값

객체가 제공하는 모든 오퍼레이션 집합을 객체의 *인터페이스*라고 보루며, 서로 다른 인터페이스를 구분할 때 사용되는 명칭이 바로 *타입이다*.  
(여기서 말하는 인터페이스는 자바언어나 C# 언어에 포함되어 있는 인터페이스가 아니라, 객체 지향에서 오퍼레이션 집합을 표현할 때 사용되는 용어이다. 인터페이스는 객체를 사용하기 위한 일종의 명세나 규칙이라고 생각하면 된다.)  
#### 2.3 메시지
객체 지향은 기능을 제공하는 여러 객체들이 모여서 완성된 어플리케이션을 구성하게 된다. 
이때 오퍼레이션의 실행을 요청하는 것을 *메시지*를 보낸다고 표현한다. (자바와 같은 언어에서는 메서드를 호출하는 것이 메시지를 보내는 과정에 해당)  
##
### 3. 객체의 책임과 크기  
객체는 객체가 제공하는 기능으로 정의된다고 했는데,  이는 다시 말하면 *객체마다 자신만의 책임*이 있다는 의미이다.  
힌 객체가 갖는 책임을 정의한 것이 바로 *타입/인터페이스*라고 생각하면 된다.  
객체가 얼마나 많은 기능을 제공할 것인가에 대한 확실한 규칙이 하나 존재하는데, 그 규칙은 *객체가 갖는 책임의 크기는 작을수록 좋다*는 것이다. (한 객체에 기능이 많아지면 절차 지향적인 구조를 갖게된다.)  
객체의 크기와 관련된 원칙이 있는데, 그 원칙은 바로 *단일 책임 원칙(SRP)* 이다. 단일 책임 원칙을 따르다 보면 자연스럽게 기능의 세부 내용이 변경될 때, 변경해야 할 부분이 한 곳으로 집중된다.  
즉 단일 책임 원칙은 변경의 유연함을 얻기 위한 가장 기본 원칙이다.  
##
### 4. 의존  
객체 지향적으로 프로그램을 구현하다 보면, 다른 객체가 제공하는 기능을 이요해서 자신의 기능을 완성하는 객체가 출현하게 된다.  
한 객체가 다른 객체를 생성하거나 다른 객체의 메서드를 호출할 때, 이를 그 객체에 의존한다고 표현한다. ( + 파라미터로 전달받는 경우에도 의존)  
객체를 생성하든 메서드를 호출하든 또는 파라미터로 전달받는 다른 타입에 의존을 한다는 것은 *의존하는 타입에 변경이 발생할 때 나도 함께 변경될 가능성이 높다는 것을 뜻한다.*  
#### 4.1 의존의 양면성  
+ 내가 변경되면 나에게 의존하고 있는 코드에 영향을 준다. 
+ 나의 요구가 변경되면 내가 의존하고 있는 타입에 영향을 준다.  
##
### 5. 캡슐화  
객체 지향의 장점은 한 곳의 구현 변경이 다른 곳에 변경을 가하지 않도록 해준다는데 있다. **즉, 수정을 좀더 원활하게 할 수 있도록 하는 것이 객체 지향적으로 프로그래밍을 하는 이유인 것이다.**  
객체 지향은 기본적으로 **캡슐화를 통해서 한 곳의 변화가 다른 곳에 미치는 영향을 최소화한다.**  

**캡슐화는 객체가 내부적으로 기능을 어떻게 구현하는지를 감추는 것이다.**  
이를 통해 내부의 기능 구현이 변경되더라도 그 기능을 사용하는 코드는 영향을 받지 않도록 만들어 준다. **즉, 내부 구현 변경의 유연함을 주는 기법이 바로 캡슐화이다.**  
#### 5.3 캡슐화의 결과는 내부 구현 변경의 유연성 획득  
기능 구현을 캡슐화하면 내부 구현이 변경되더라도, 기능을 사용하는 곳의 영향을 최소화할 수 있다.  **즉, 캡슐화를 잘 할수록 보다 쉽게 구현을 변경할 수 있게 된다.**  
#### 5.4 캡슐화를 위한 두 개의 규칙  
객체 지향을 처음 접하는 사람들은 그동안 몸에 밴 절차 지향 방식 습관 때문에 무심결에 데이터 중심적인 코드를 만들기 쉽다.  
이런 습관을 고치는 데 도움이 되는 두 개의 규칙이 있는데 그 규칙은 다음과 같다.  
+ Tell, Don't Ask  
    - 데이터를 물어보지 않고, 기능을 실행해 달라고 말하라.
        - 데이터를 읽는 것은 데이터를 중심으로 코드를 작성하게 만드는 원인(절차지향적 프로그래밍)
        - 기능 실행을 요청하는 방식으로 코드를 작성하다 보면, 자연스럽게 해당 기능을 어떻게 구현했는지 여부가 감춰진다(즉, 기능 구현이 캡슐화 된다.)  
+ 데미테르의 법칙(Law of Demeter)  
    - 'Tell, Dont't Ask' 규칙을 따를 수 있도록 만들어 주는 또 다른 규칙.  
        + 메서드에서 생성한 객체의 메서드만 호출  
        + 파라미터로 받은 객체의 메서드만 호출  
        + 필드로 참조하는 객체의 메서드만 호출  

테미테르의 법칙을 지키지 않는 전형적은 증상 두 가지가 있는데, 이 둘은 다음과 같다.  
+ 연속된 get 메서드 호출  
+ 임시 변수의 get 호출이 많음  

두가지 증상이 보인다면 데미테르의 법칙을 어기고 있을 가능성이 높고, 이는 캡슐화를 약화시켜서 코드 변경을 어렵게 만드는 원인이 될 수 있다.  
따라서 위의 두 가지 증상이 보인다면 데미테르의 법칙을 어기고 있는지 잘 확인해 보고 관련 기능을 적극적으로 캡슐화하도록 한다.  
### 6. 객체지향 설계과정  
객체 지향 설계란 다음의 작업을 반복하는 과정이라고 볼 수 있다.  
1. 제공해야 할 기능을 찾고 또는 세분화하고, 그 기능을 알맞은 객체에 할당한다.  
    A. 기능을 구현하는 데 필요한 데이터를 객체에 추가한다. 객체에 데이터를 먼저 추가하고 그 데이터를 이용하는 기능을 넣을 수도 있다.  
    B. 기능은 최대한 캡슐화해서 구현한다.  
2. 객체 간에 어떻게 메시지를 주고받을 지 결정한다.  
3. 과정1과 과정2를 개발하는 동안 지속적으로 반복한다.  
객체의 크기는 한번에 완성되기 보다는 구현을 진행하는 과정에서 점진적으로 명확해진다. 따라서 설계를 할 떄에는 변경되는 부분을 고려한 유연한 구조를 갖도록 노력해야 한다.  



