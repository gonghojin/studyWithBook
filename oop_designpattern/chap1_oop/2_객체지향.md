## 객체 지향
객체 지향을 잘 하려면  이와 대조되는 개법인 절차 지향적으로 프로그램을 작성하면 안된다. 객체 지향을 지원하는 언어를 사용하더라도 실제 결과물은 객체 지향과 거리가 멀어질 수 있다.  
이런 결과가 나오는 이유는 객체 자체와 객체 지향의 핵심인 *캡슐화 및 추상화가 적용되지 않았기 때문이다.*  
##
### 1. 절차 지향과 객체 지향
#### 1.1 절차지향  
데이터를 조작하는 코드를 별도로 분리해서 함수나 프로시저와 같은 형태로 만들고, 각 프로시저들이 데이터를 조작하는 방식으로 코드를 작성할 수 있을 것이다.  
프로시저는 다른 프로시저를 사용할 수도 있고, 각각의 프로시저가 같은 데이터를 사용할 수 있다.  
*이렇게 프로시저로 프로그램을 구성하는 기법을 절차지향 프로그래밍이라고 부른다.*
####1.2 객체 지향
절차 지향과 달리 *객체 지향은 데이터 및 데이터와 관련된 프로시저를 객체라고 불리는 단위로 묶는다.*  
객체는 프로시저를 실행하는데 필요한 만큼의 데이터를 가지며, 객체들이 모여 프로그램을 구성한다.  
모든 프로시저가 데이터를 공휴하는 절차 지향과 달리 *객체 지향은 객체 별로 데이터와 프로시저를 알맞게 정의해야 한다.*  
##
### 2. 객체
#### 2.1 객체의 핵심은 기능을 제공하는 것  
객체 지향의 가장 기본은 객체다. 앞서 객체는 데이터와 그 데이터를 조작하는 프로시저(오퍼레이션, 메서드, 함수로)로  구성된다고 했는데, 이는 객체의 물리적인 특징일 뿐이다.  
실제로 객체를 정의할 때 사용되는 것은 *객체가 제공해야할 기능이며, 객체가 내부적으로 어떤 데이터를 갖고 있는 지로는 정의되지 않는다.*  
#### 2.2 인터페이스와 클래스  
객체는 객체가 제공하는 기능으로 정의된다고 했는데, 보통 객체가 제공하는 기능을 *오퍼레이션*이라고 부른다. *즉, 객체는 오퍼세이션으로 정의가 된다.*  
오퍼레이션의 사용법은 일반적으로 다음과 같이 세개로 구성되며, 이 세 가지를 합쳐서 *시그니처*라고 부른다
+ 기능 식별 이름
+ 파라미터 및 파티미터 타입
+ 기능 실행 결과 값

객체가 제공하는 모든 오퍼레이션 집합을 객체의 *인터페이스*라고 보루며, 서로 다른 인터페이스를 구분할 때 사용되는 명칭이 바로 *타입이다*.  
(여기서 말하는 인터페이스는 자바언어나 C# 언어에 포함되어 있는 인터페이스가 아니라, 객체 지향에서 오퍼레이션 집합을 표현할 때 사용되는 용어이다. 인터페이스는 객체를 사용하기 위한 일종의 명세나 규칙이라고 생각하면 된다.)  
#### 2.3 메시지
객체 지향은 기능을 제공하는 여러 객체들이 모여서 완성된 어플리케이션을 구성하게 된다. 
이때 오퍼레이션의 실행을 요청하는 것을 *메시지*를 보낸다고 표현한다. (자바와 같은 언어에서는 메서드를 호출하는 것이 메시지를 보내는 과정에 해당)  
##
### 3. 객체의 책임과 크기  
객체는 객체가 제공하는 기능으로 정의된다고 했는데,  이는 다시 말하면 *객체마다 자신만의 책임*이 있다는 의미이다.  
힌 객체가 갖는 책임을 정의한 것이 바로 *타입/인터페이스*라고 생각하면 된다.  
객체가 얼마나 많은 기능을 제공할 것인가에 대한 확실한 규칙이 하나 존재하는데, 그 규칙은 *객체가 갖는 책임의 크기는 작을수록 좋다*는 것이다. (한 객체에 기능이 많아지면 절차 지향적인 구조를 갖게된다.)  
객체의 크기와 관련된 원칙이 있는데, 그 원칙은 바로 *단일 책임 원칙(SRP)* 이다. 단일 책임 원칙을 따르다 보면 자연스럽게 기능의 세부 내용이 변경될 때, 변경해야 할 부분이 한 곳으로 집중된다.  
즉 단일 책임 원칙은 변경의 유연함을 얻기 위한 가장 기본 원칙이다.  
##
### 4. 의존  
객체 지향적으로 프로그램을 구현하다 보면, 다른 객체가 제공하는 기능을 이요해서 자신의 기능을 완성하는 객체가 출현하게 된다.  
한 객체가 다른 객체를 생성하거나 다른 객체의 메서드를 호출할 때, 이를 그 객체에 의존한다고 표현한다. ( + 파라미터로 전달받는 경우에도 의존)  
객체를 생성하든 메서드를 호출하든 또는 파라미터로 전달받는 다른 타입에 의존을 한다는 것은 *의존하는 타입에 변경이 발생할 때 나도 함께 변경될 가능성이 높다는 것을 뜻한다.*  
#### 4.1 의존의 양면성  
+ 내가 변경되면 나에게 의존하고 있는 코드에 영향을 준다. 
+ 나의 요구가 변경되면 내가 의존하고 있는 타입에 영향을 준다.  


< 타입 상속을 통한 다형성 구현 >

public class Plane {
    public void fly() {
        // 비행
    }
}

public interface Turbo {
    public void boost();
}

public class TurboPlane extends Plane implements Turbo {
    public void boost() {
        // 가속
    }
}

---

TurboPlane tp = new TurboPlane();
tp.fly() // Plane에 정의/구현된 메서드 실행
tp.boost(); // Turbo에 정의되고 TurboPlane에 구현된 메서드 실행

---

TurboPlane tp = new TurboPlane();

Plane p = tp //  TurboPalne 객체는 Plane 타입도 된다.
p.fly();

Turbo t = tp; // TurboPlane 객체는 Turbo 타입도 된다.
t.boost(); 