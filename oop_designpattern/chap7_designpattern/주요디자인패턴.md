## 7. 주요 디자인 패턴
객체 지향 설계는 소프트웨어로 해결하고자 하는 문제를 다루면서, 동시에 재설계없이 또는 재설계를 최소화하면서 요구사항의 변화를 수용할 수 있도록 만들어 준다.  
객체 지향 설계를 하다 보면, 비슷한 상황에서 사용했던 설계를 재사용하는 경우가 종종 발생한다. 이렇게 반복적으로 사용되는 설계는 클래스, 객체의 구성, 객체 간 메시지 흐름에서 일정 패턴을 갖는다.  
이런 패턴을 잘 습득하면 다음과 같은 이득을 얻을 수 있게 된다.  
+ 상황에 맞는 올바른 설계를 더 빠르게 적용할 수 있다.
+ 각 패턴의 장단점을 통해서 설계를 선택하는 데 도움을 얻을 수 있다.
+ 설계 패턴에 이름을 붙임으로써 시스템의 문서화, 이해, 유지 보수에 도움을 얻을 수 있다.    

자주 사용되는 패턴
+ 전략 패턴  / 템플릿 메서드 패턴 / 상태 패턴
+ 데코레이터 패턴 / 프록시 패턴 / 어댑터 패턴
+ 옵저버 패턴 / 미디에이터 패턴 / 파사드 패턴
+ 추상 팩토리 패턴 / 컴포지트 패턴 

~~~
<전략 패턴>
전략패턴을 적용할 떄 얻을 수 있는 이점은 콘텍스트 코드의 변경없이 새로운 전략을 추가할 수 있다.  
일반적으로 if-else로 구성된 코드 블록이 비슷한 기능을 수행하는 경우에 전략 패턴을 적용함으로써 코드를 확장 가능하도록 변경할 수 있다.
즉, 비슷한 코드를  실행하는  if-else 블록은 전략 패턴 적용 대상이다.

또한 전략 패턴은 동일한 기능의 알고리즘 변경이 필요할 때 사용
~~~
~~~
<템플릿 메서드 패턴>
프로그램을 구현하다 보면, 완전히 동일한 절차를 가진 코드를 작성하게 될 때가 있다. 심지어 이 코드들은 절차 중 일부 과정의 구현만 다를 뿐 나머지의 구현은 똑같을 떄도 있다.  
이렇게 실행과정/단계는 동일한데 각 단계 중 일부의 구현이 다른 경우에 사용할 수 있는 패턴이 '템플릿 메서드 패턴'이다.

템플릿 메서드 패턴은 두 가지로 구성된다.
1. 실행 과정을 구현한 상위 클래스
2. 실행 과정의 일부 단계를 구현한 하위 클래스

템플릿 메서드 패턴을 사용하게 되며느 동일한 실행과정의 구현을 제공하면서 동시에 하위 타입에서 일부 단계를 구현하도록 할 수 있다. 이는 각 타입에서 코드가 중복되는 것을 방지한다.
중복된 코드가 출현한다는 것은 그만큼 유지보수를 어렵게 만드는 데, 템플릿 메서드 패턴을 사용함으로써 코드 중복 문제를 제거하면서 동시에 코드를 재사용할 수 있게 된다.

[상위 클래스가 흐럼제어 주체]
템플릿 메서드 페턴의 특징은 하위 클래스가 아닌 상위 클래스에서 흐름 제어를 한다는 것이다. (일반적인 경우 하위 타입이 상위 타입의 기능을 재사용할지 여부를 결정하기 때문에, 흐름제어를 하위타입이 하게된다)
    + 흑(hook) 메서드 :
        상위 클래스에서 실행 시점이 제어되고, 기본 구현을 제공하면서, 하위 클래스에서 알맞게 확장할 수 있는 메서드
~~~

### 3.2 템플릿 메서드와 전략 패턴의 조합
템플릿 메서드와 전략 패턴을 함께 사용하면 상속이 아닌 조립의 방식으로 템플릿 메서드 패턴을 활용할 수 있다.   
조합을 할 경우, 상속에 기반을 둔 템플릿 메서드 구현과 비교할 경우, 보다 유연성을 가진다.  

장점:
- 상속을 통한 재사용의 경우, 런타임에 교체할 수 없는 단점이 있는 반면에 조립/위임을 사용하는 경우에는 런타임에 템플릿 메서드에서 사용할 객체를 교체할 수 있다.
- 또한 상속을 통한 재사용 시, 불필요하게 클래스가 증가할 수 있다.  

단점:
- 상속 방식의 경우 훅 메서드를 재정의 하는 방법으로 하위 클래스에서 쉽게 확장기능을 제공할 수 있는 장점이 있는 반면에, 조립/위임 방식에서는 확장 기능을 제공하려면 구현이 다소 복잡해지는 단점이 있다.  

##
### 4. 상태 패턴
장점 :   
- 새로운 상태가 추가되더라도 콘텍스트 코드가 받는 영향은 최소화된다. 
    - 상태 패턴을 적용하지 않을 경우, 상태가 많아질 경우 조건문을 이용한 방식은 코드가 복잽해져 유지보수를 어렵게 만들지만, 상태 패턴의 경우 코드의 복잡도는 증가하지 않기 떄문에 유지보수면에서 유리
-  상태에 따른 동작을 구현한 코드가 각 상태 별로 구분되기 떄문에 상태 별 동작을 수정하기가 쉽다.  
    - 조건문을 이요한 방식을 사용할 경우, 동적 없음 상태의 동작을 수정하려면 각 메서드를 찾아다니면서 수정해 주어야 하는 반면에, NoCoinState 클래스만 수정해주면 된다.(관련된 코드가 한곳에 모여있기 떄문에 안전하고 더 빠르게 구현을 변경할 수 있따.)

### 4.1 상태 변경은 누가
상태 패턴을 적용할 때 고려할 문제는 **콘텍스트의 상태 변경을 누가 하느냐**에 대한 것이다.  
상태 변경을 하는 주체는 콘텍스트나 상태 객체 둘 중 하나가 된다.  
콘텍스트의 상태 변경을 누가 할지는 주어진 상황에 알맞게 정해 주어여 한다. 
~~~
<콘텍스트에서 상태 변경>
    비교적 상태 개수가 적고 상태 변경 규칙이 상태 변경 규칙이 거의 바뀌지 않는 경우에 유리하다.
    왜 ? ) 상태 종류가 지속적으로 변경되거나 상태 변경 규칙이 상태 변경 규칙이 자주 바뀔 경우, 콘텍스트의 상태 변경 처리코드가 복잡해질 가능성이 높기 때문이다.
          상태 변경 처리 코드가 복잡해질수록 상태 변경의 유연함이 떨어진다.

<상태 객체에서 콘텍스트의 상태를 변경>
    콘텍스트에 영향을 주지 않으면서 상태를 추가하거나 상태 변경 규칙을 바꿀 수 있다. 하지만 상태 변경 규칙이 여러 클래스에 분산되어 있기 때문에,
    상태 구현 클래스가 많아질수록 상태 변경 규칙을 파악하기가 어려워진다. 또한 한 상태 클래스에서 다른 상태 클래스에 대한 의존도 발생한다.
    
 두 방식은 명확하게 서로 상반되는 장단점을 갖고 있기 떄문에, 상태 패턴을 적용할 떄에는 주어진 상황에 알맞은 방식을 선택해야한다.
 ~~~
 