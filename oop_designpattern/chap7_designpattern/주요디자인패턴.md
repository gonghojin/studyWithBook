## 7. 주요 디자인 패턴
객체 지향 설계는 소프트웨어로 해결하고자 하는 문제를 다루면서, 동시에 재설계없이 또는 재설계를 최소화하면서 요구사항의 변화를 수용할 수 있도록 만들어 준다.  
객체 지향 설계를 하다 보면, 비슷한 상황에서 사용했던 설계를 재사용하는 경우가 종종 발생한다. 이렇게 반복적으로 사용되는 설계는 클래스, 객체의 구성, 객체 간 메시지 흐름에서 일정 패턴을 갖는다.  
이런 패턴을 잘 습득하면 다음과 같은 이득을 얻을 수 있게 된다.  
+ 상황에 맞는 올바른 설계를 더 빠르게 적용할 수 있다.
+ 각 패턴의 장단점을 통해서 설계를 선택하는 데 도움을 얻을 수 있다.
+ 설계 패턴에 이름을 붙임으로써 시스템의 문서화, 이해, 유지 보수에 도움을 얻을 수 있다.    

자주 사용되는 패턴
+ 전략 패턴  / 템플릿 메서드 패턴 / 상태 패턴
+ 데코레이터 패턴 / 프록시 패턴 / 어댑터 패턴
+ 옵저버 패턴 / 미디에이터 패턴 / 파사드 패턴
+ 추상 팩토리 패턴 / 컴포지트 패턴 

~~~
<전략 패턴>
전략패턴을 적용할 떄 얻을 수 있는 이점은 콘텍스트 코드의 변경없이 새로운 전략을 추가할 수 있다.  
일반적으로 if-else로 구성된 코드 블록이 비슷한 기능을 수행하는 경우에 전략 패턴을 적용함으로써 코드를 확장 가능하도록 변경할 수 있다.
즉, 비슷한 코드를  실행하는  if-else 블록은 전략 패턴 적용 대상이다.

또한 전략 패턴은 동일한 기능의 알고리즘 변경이 필요할 때 사용
~~~
~~~
<템플릿 메서드 패턴>
프로그램을 구현하다 보면, 완전히 동일한 절차를 가진 코드를 작성하게 될 때가 있다. 심지어 이 코드들은 절차 중 일부 과정의 구현만 다를 뿐 나머지의 구현은 똑같을 떄도 있다.  
이렇게 실행과정/단계는 동일한데 각 단계 중 일부의 구현이 다른 경우에 사용할 수 있는 패턴이 '템플릿 메서드 패턴'이다.

템플릿 메서드 패턴은 두 가지로 구성된다.
1. 실행 과정을 구현한 상위 클래스
2. 실행 과정의 일부 단계를 구현한 하위 클래스

템플릿 메서드 패턴을 사용하게 되며느 동일한 실행과정의 구현을 제공하면서 동시에 하위 타입에서 일부 단계를 구현하도록 할 수 있다. 이는 각 타입에서 코드가 중복되는 것을 방지한다.
중복된 코드가 출현한다는 것은 그만큼 유지보수를 어렵게 만드는 데, 템플릿 메서드 패턴을 사용함으로써 코드 중복 문제를 제거하면서 동시에 코드를 재사용할 수 있게 된다.

[상위 클래스가 흐럼제어 주체]
템플릿 메서드 페턴의 특징은 하위 클래스가 아닌 상위 클래스에서 흐름 제어를 한다는 것이다. (일반적인 경우 하위 타입이 상위 타입의 기능을 재사용할지 여부를 결정하기 때문에, 흐름제어를 하위타입이 하게된다)
    + 흑(hook) 메서드 :
        상위 클래스에서 실행 시점이 제어되고, 기본 구현을 제공하면서, 하위 클래스에서 알맞게 확장할 수 있는 메서드
~~~

### 3.2 템플릿 메서드와 전략 패턴의 조합
템플릿 메서드와 전략 패턴을 함께 사용하면 상속이 아닌 조립의 방식으로 템플릿 메서드 패턴을 활용할 수 있다.   
조합을 할 경우, 상속에 기반을 둔 템플릿 메서드 구현과 비교할 경우, 보다 유연성을 가진다.  

장점:
- 상속을 통한 재사용의 경우, 런타임에 교체할 수 없는 단점이 있는 반면에 조립/위임을 사용하는 경우에는 런타임에 템플릿 메서드에서 사용할 객체를 교체할 수 있다.
- 또한 상속을 통한 재사용 시, 불필요하게 클래스가 증가할 수 있다.  

단점:
- 상속 방식의 경우 훅 메서드를 재정의 하는 방법으로 하위 클래스에서 쉽게 확장기능을 제공할 수 있는 장점이 있는 반면에, 조립/위임 방식에서는 확장 기능을 제공하려면 구현이 다소 복잡해지는 단점이 있다.  

##
### 4. 상태 패턴
장점 :   
- 새로운 상태가 추가되더라도 콘텍스트 코드가 받는 영향은 최소화된다. 
    - 상태 패턴을 적용하지 않을 경우, 상태가 많아질 경우 조건문을 이용한 방식은 코드가 복잽해져 유지보수를 어렵게 만들지만, 상태 패턴의 경우 코드의 복잡도는 증가하지 않기 떄문에 유지보수면에서 유리
-  상태에 따른 동작을 구현한 코드가 각 상태 별로 구분되기 떄문에 상태 별 동작을 수정하기가 쉽다.  
    - 조건문을 이요한 방식을 사용할 경우, 동적 없음 상태의 동작을 수정하려면 각 메서드를 찾아다니면서 수정해 주어야 하는 반면에, NoCoinState 클래스만 수정해주면 된다.(관련된 코드가 한곳에 모여있기 떄문에 안전하고 더 빠르게 구현을 변경할 수 있따.)

### 4.1 상태 변경은 누가
상태 패턴을 적용할 때 고려할 문제는 **콘텍스트의 상태 변경을 누가 하느냐**에 대한 것이다.  
상태 변경을 하는 주체는 콘텍스트나 상태 객체 둘 중 하나가 된다.  
콘텍스트의 상태 변경을 누가 할지는 주어진 상황에 알맞게 정해 주어여 한다. 
~~~
<콘텍스트에서 상태 변경>
    비교적 상태 개수가 적고 상태 변경 규칙이 상태 변경 규칙이 거의 바뀌지 않는 경우에 유리하다.
    왜 ? ) 상태 종류가 지속적으로 변경되거나 상태 변경 규칙이 상태 변경 규칙이 자주 바뀔 경우, 콘텍스트의 상태 변경 처리코드가 복잡해질 가능성이 높기 때문이다.
          상태 변경 처리 코드가 복잡해질수록 상태 변경의 유연함이 떨어진다.

<상태 객체에서 콘텍스트의 상태를 변경>
    콘텍스트에 영향을 주지 않으면서 상태를 추가하거나 상태 변경 규칙을 바꿀 수 있다. 하지만 상태 변경 규칙이 여러 클래스에 분산되어 있기 때문에,
    상태 구현 클래스가 많아질수록 상태 변경 규칙을 파악하기가 어려워진다. 또한 한 상태 클래스에서 다른 상태 클래스에 대한 의존도 발생한다.
    
 두 방식은 명확하게 서로 상반되는 장단점을 갖고 있기 떄문에, 상태 패턴을 적용할 떄에는 주어진 상황에 알맞은 방식을 선택해야한다.
 ~~~
 ##
 ### 5. 데코레이터(Decorator) 패턴
 상속은 기능을 확장하는 방법을 제공한다. 상속을 이용한 기능 확장 방법이 쉽긴하지만, 다양한 조합의 기능 확장이 요구될 때 클래스가 불필요하게 증가하는 문제가 발생된다.  
 이런 경우에 사용할 수 있는 패턴이 **데코레이터 패턴이다.** 데코레이터 패턴은 상속이 아닌 위임을 하는 방식으로 기능을 확장해 나간다.  
 #### 5.1 데코레이터 패턴을 적용할 때 고려할 점  
 + 데코레이터 대상이 되는 타입의 기능 개수에 대한 것.  
 + 데코레이터 객체가 비정상적으로 동작할 때 어떻게 처리할 것이냐에 대한 것.  
 데코레이터의 단점은 사용자 입장에서 데코레이터 객체와 실제 구현 객체의 구분이 되지 않기 때문에 코드만으로는 기능이 어떻게 동작하는지 이해하기 어렵다.  
 ##
 ### 6. 프록시(Proxy) 패턴
 프록시 패턴은 실제 객체를 대신하는 프록시 객체를 사용해서 실제 객체의 생성이나 접근 등을 제어할 수 있도록 해주는 패턴.  
 
 프록시의 종류  
 + 가상 프록시 : 필요한 순간에 실제 객체를 생성해 주는 프록시  
 + 보호 프록시 : 실제 객체에 대한 접근을 제어하는 프록시로서, 접근 권한이 있는 경우에만 실제 객체의 메서드를 실행하는 방식으로 구현  
 + 원격 프록시 : 자바의 RMI(Remote Method Invocation)처럼 다른 프로세스에 존재하는 객체에 접근할 때 사용되는 포록시이다.  
   원격 프록시는 내부적으로 IPC(Inter process communication)이나 TCP 통신을 이용해서 다른 프로세스의 객체를 실행하게 된다.  
 #### 6.1 프록시 패턴을 적용할 때 고려할 점  
 프록시를 구현할 때 고려할 점은 실제 객체를 누가 생성할 것이냐에 대한 것이다.  
 가상프록시는 필요한 순간에 실제 객체를 생성하는 경우가 많기 때문에, **가상 프록시에서 실제 생성할 객체의 타입을 사용하게 된다.**  
 반면에 접근 제어를 위한 목적으로 사용되는 보호 프록시는 보호 프록시 객체를 생성할 때 실제 객체를 전달하면 되므로, **실제 객체의 타입을 알 필요없이 추상 타입을 사용하면 된다.**  
 ##
 ### 7. 어댑터(Adapter) 패턴  
 클라이언트가 요구하는 인터페이스와 재사용하려는 모듈의 인터페이스가 일치하지 않을 때 사용할 수 있는 패턴으로 개방 폐쇄 원칙을 따를 수 있도록 도와준다.  
 어댑터 패턴은 조립 방식과 상속 방식이 있다. 상속 방식에서 SearchService가 인터페이스가 아닌 일부 구현이 포함된 추상 클래스라면, 자바와 같이 클래스 단일 상속만을 지원하는 언어에서는 클래스 상속을 이용한 어댑터 구현에 제약을 받게 된다(p. 241)
##
### 8. 옵저버(Observer) 패턴
한 객체의 상태 변화를 정해지지 않은 여러 다른 객체에게 통지하고 싶을 때 사용되는 패턴이 옵저버 패턴이다.  
옵저버 패터네는 크게 주제(subject) 객체와 옵저버(observer) 객체가 등장하는데, 주제 객체는 다음의 두 가지 책임을 갖는다.  
+ 옵저버 목록을 관리하고, 옵저버를 등록하고 제거할 수 있는 메서드를 제공한다.  
+ 상태의 변경이 발생하면 등록된 옵저버에 변경 내역을 알린다.  

옵저버 패턴을 적용할 떄의 장점 : 주제 클래스 변경없이 상태 변경을 통지 받을 옵저버를 추가할 수 있다.  
#### 8.3 옵저버 패턴 구현의 고려 사항
+ 주제 객체의 통지 기능 실행 주체
+ 옵저버 인터페이스의 분리
+ 통지 시점에서의 주제 객체 상태
+ 옵저버 객체의 실행 제약 조건 
~~~
<주제 객체의 통지 기능 실행 주체>
주제 객체의 상태가 바뀔 때마다 오버버에게 통지를 해 주어야 한다면, 주제 객체에서 직접 통지 기능을 실행하는 것이 구현에 유리하다.  
왜?) 상태를 변경하는 모든 코드에서 통지기능을 함께 호출해야 하기 때문에, 통지 기능을 호출하지 않는 등 개발자의 실수를 유발  

반대로, 한 개 이상의 주제 객체의 연속적인 상태 변경 이후에 옵저버에게 통지를 해야 한다면, 주제 객체가 아닌 주제 객체의 상태를 변경하는 코드에서 통지 기능을 실행해 주도록 구현하는 것이  
      통지 시점을 관리하기가 수월하다.  

<옵저버 인테페이스의 분리>
한 주제 객체가 통지할 수 있는 상태 변경 내역의 종류가 다양한 경우에는 각 종류 별로 옵저버 인터페이스를 분리해서 구현하는 것이 좋다.  
왜?) 모든 종류의 상태 변경을 하나의 옵저버 인터페이스로 처리할 경우, 옵저버 인터페이스가 거대해지기 때문  
    또한, 주제 객체 입장에서도 각 상태마다 변경의 이유가 다르기 때문에, 이들을 한 개의 옵저버 인터페이스로 관리하는 것은 향후에 변경을 어렵게 만드는 요인이 될 수 있다.

<통지 시점에서의 주제 객체 상태>
통지시점에서 주제 객체의 상태에 결함이 없어아 햔다.

<옵저버 객체의 실행 제약 조건>
옵저버 인터페이스를 정의할 때에는 옵저버 메서드의 실행 제한에 대한 명확한 기준이 필요하다.

<기타>
옵저버 객체에서 주제 객체의 상태를 다시 변경하면 어떻게 구현할 것인가?  
옵저버 자체를 비동기로 실행하는 문제 등  
~~~ 
##
### 9. 미디에이터(Mediator) 패턴  
객체 간의 메시지 흐름을 각 클래스에 직접적인 의존으로 구현하게 되면, 개별 클래스의 재사용이 어려워지고 메시지 흐름을 변경하려면 관련된 클래스들을 모두 변경해 주어야 하는 문제가 발생하게 된다.  
*미디에이터 패턴*을 사용하면 이런 문제를 해소할 수 있다. *미디에이터 패턴은 각 객체들이 직접 메시지를 주고받는 대신, 중간에 중계 역할을 수행하는 미디에이터 객체를 두고 미디에이터를 통해서 각 객체들이 간접적으로 메시지를 주고 받도록 한다.*  
미디에이터 패턴은 각 협업 클래스에 흩어져 있는 흐름 제어를 미디에이터로 모으기 때문에, 각 협업 클래스의 코드는 단순해진다. 각 협업 클래스는 미디에이터에만 의존하거나 또는 (옵저버 패턴등을 사용해서) 미디에이터나 다른 협업 클래스에 의존하지 않기 때문에, 개별 협업 클래스를 수정하거나 확장하거나 재사용하기가 쉬워진다.  
또한, 미디에이터에 각 협업 객체의 흐름 제어코드가 모여 있기 때문에 전체 협업 객체 간의 메시지 흐름을 이해하고 수정하고 확장하는 것을 상대적으로 쉽게 만들어 준다.  

반면에, 미디에이터 패턴을 사용할 때의 단점은 협업 클래스의 개수가 증가할수록 미디에이터의 코드는 복잡해지기 때문에, 미디에이터 자체를 유지 보수하는 것은 협업 클래스에 비해 어려워 진다는 것이다.  
#### 9.1 추상 미디에이터 클래스의 재사용  
미디에이터 패턴을 적용할 때 협업 객체 간의 동일한 메시지 흐름이 서로 다른 기능에서 반복해서 사용될 경우, 미디에이터 추상 클래스를 사용함으로써 미디에이터 자체의 재사용을 높일 수 있다.
##
### 10. 파사드(Facade) 패턴  
코드 중복과 직접적인 의존을 해결하는 데 도움을 주는 패턴이 *파사드 패턴*이다. 파사드 패턴은 서브 시스템을 감춰 주는 상위 수준의 인터페이스를 제공함으로써 이 문제를 해결한다.  
각 클라이언트는 파사드를 이용해서 서브시스템에 간접적으로 접근한다. 이 과정에서 클라이언트의 코드가 간결해지고 *가장 중요한 것은 클라이언트와 서브 시스템 간의 직접적인 의존을 제거했다는 점이다.*  
*즉, 파사드 패턴을 적용하면 클라이언트는 파사드에만 의존하기 떄문에, 서브 시스템의 일부가 변경되더라도 그 여파는 파사드로 한정될 가능성이 높다.*  
#### 10.1 파사드 패턴의 장점과 특징  
클라이언트와 서브 시스템 간의 결합을 제거함으로써 얻을 수 있는 또 다른 이점은 파사드를 인터페이스로 정의함으로써 클라이언트의 변경없이 서브시스템 자체를 변경할 수 있다는 것이다.  
파사드 패턴을 적용한다고 해서 서브 시스템에 대한 직접적인 접근을 막는 것은 아니다. 파사드 패턴은 단지 여러 클라이언트에 중복된 서브 시스템 사용을 파사드로 추상화할 뿐이다.  
따라서 다수의 클라이언트에 공통된 기능은 파사드를 통해서 쉽게 서브 시스템을 사용할 수 있도록 하고, 보다 세밀한 제어가 필요한 경우에는 서브 시스템에 직접 접근하는 방식을 선택할 수 있다.  
~~~
파사드 패턴을 클래스와 비교해 보면, 파사드는 마치 서브 시스템의 상세함을 감춰 주는 인터페이스와 유사하다.  
파사드를 통해서 서브 시스템의 상세한 구현을 캡슐화하고, 이를 통해 상세한 구현이 변경되더라도 파사드를 사용하는 코드에 주는 영향을 줄일 수 있게 된다.
~~~
