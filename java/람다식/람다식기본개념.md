람다식 기본개념[이것이 자바다 정리]
===
14.3 타켓 타입과 함수적 인터페이스  
---
람다식의 형태는 매개 변수를 가진 코드 블록이기 때문에, 마치 자바의 메소드를 선언하는 것처럼 보여진다.  
자바는 메소드를 단독으로 선언할 수 없고 항상 클래스의 구성 멤버로 선언하기 때문에 **람다식은 단순히 메소드를 선언하는 것이아니라, 이 메소드를 가지고 있는 객체를 생성해낸다.**  
~~~
인터페이스 변수 = 람다식
~~~
람다식은 인터페이스 변수에 대입된다. 이말은 람다식은 인터페이스의 익명 구현 객체를 생성한다는 뜻이 된다.  
인터페이스는 직접 객체화할 수 없기 때문에 구현 클래스가 필요한데, 람다식은 **익명 구현클래스를 생성하고 객체화한다.**  
람다식은 대입될 인터페이스의 종류에 따라 작성 방법이 달라지기 때문에, 람다식이 대입될 인터페이스를 **람다식의 타켓 타입**이라고 한다.  

#### 14.3.1 함수적 인터페이스(@FunctionalInterface) - 하나의 추상 메소드가 선언된 인터페이스
모든 인터페이스를 람다식의 타켓 타입으로 사용할 수 는 없다. **람다식이 하나의 메소드를 정의하기 떄문에 두 개 이상의 추상 메소드가 선언된 인터페이스는 람다식을 이용해서 구현 객체를 생성할 수 없다.**  
따라서 하나의 추상 메소드가 선언된 인터페이스만이 람다식의 타켓 타입이 될 수 있는데, 이러한 인터페이스를 **함수적 인터페이스**라고 한다.  
함수적 인터페이스를 작성할 떄 두 개 이상의 추상 메소드가 선언되지 않도록 컴파일러가 체킹해주는 기능이 있는데, 인터페이스 선언 시 @FunctionalInterface 어노테이션을 붙이면 된다.  
이 어노테이션은 두 개 이상의 추상 메소드가 선언되면 컴파일 오류를 발생시킨다.  
~~~
@FunctionalInterface
puvlic interface MyFunctionalInterface {
    public void method();
    public void otherMethod(); // 컴파일 오류
}

@FunctionalInterface 어노테이션은 선택사항이다.  
이 어노테이션이 없더라도 하나의 추상 메소드만 있다면 모두 함수적 인터페이스다. 그러나 실수로 두 개 이상의 추상 메소드를 선언하는 것을 방지하고 싶다면 붙여주는 것이 좋다.  
~~~

람다식은 타켓 타입인 함수적 인터페이스가 가지고 있는 추상 메소드의 선언 형태에 따라서 작성 방법이 달라는데, 그에 대해서 알아보자!!  
#### 14.3.2 매개변수와 리턴값이 없는 람다식  
다음과 같이 매개변수와 리턴값이 없는 추상 메소드를 가진 함수적 인터페이스가 있다고 가정해보자.
~~~
@FunctionalInterface
public interface MyFunctionalInterface {
    public void method();
}
~~~
이 인터페이스를 타켓 타입으로 갖는 람다식은 다음과 같은 형태로 작성해야 한다. 람다식에서 매개변수가 없는 이유는 method()가 매개변수를 가지지 않기 때문이다.  
~~~
MyFunctionalInterface fi = () -> {...}
~~~
람다식이 대입된 인터페이스의 참조변수는 다음과 같이 method()를 호출할 수 있다. method() 호출은 람다식의 중괄호 {}를 실행시킨다.
~~~
fi.method();
~~~
~~~
public class MyFunctionalInterfaceEx {
 public static void main(String[] args) {
    MyFunctionalInterface fi;
    
    fi = () -> {
        String str = "method call1";
        System.out.println(str); 
    };
    fi.method(); // method call1
    
    fi = () -> {
        sysout("method call2");
    };
    fi.method() // method call2

    fi = () -> sysout("method call3");
    fi.method(); // method call3
 }
}
~~~
#### 14.3.3 매개변수가 있는 람다식
다음과 같이 매개 변수가 있고 리턴값이 없는 추상메소드를 가진 함수적 인터페이스가 있다고 보자.
~~~
@FunctionalInterface
public interface MyFunctionalInterface {
    public void method(int x);
}
~~~
이 인터페이스를 타켓 타입으로 갖는 람다식은 다음과 같은 형태로 작성해야 한다. 람다식에서 매개변수가 한 개인 이유는 method()가 매개 변수를 하나만 가지기 떄문이다.  
~~~
MyFunctionalInterface fi = (x) -> {...} 또는 x ->{...}
호출 방식 :
    fi.method(5);
매개값으로 5를 주면 람다식의 x변수에 5가 대입되고, x는 중괄호 {}에서 사용
~~~
~~~
public class MyFunctionalInterfaceEx {
 public static void main(String[] args) {
    MyFunctionalInterface fi;
    
    fi = (x) -> {
        int result = x * 5;
        sout(result);
    };
    fi.method(2); // 10
    
    fi = (x) -> {
        sout(x * 5); 
    };
    fi.method(2) // 10
    
    fi = x -> sout(x * 5); // 매개 변수가 하나일 경우에는 괄호()를 생략할 수 있다.
    fi.method(2);
 }
}
~~~
#### 14.4.3.4 리턴값이 있는 람다식
다음과 같이 매개 변수가 있고 리턴값이 있는 추상 메소드를 가진 함수적 인터페이스가 있다고 보자.
~~~
@FunctionalInterface
public interface MyFunctionalInterface {
    public void method(int x, int y);
}
~~~
이 인터페이스를 타켓 타입으로 갖는 람다식은 다음과 같은 형태로 작성해야 한다. 람다식에서 매개 변수가 두 개인 이유는 method()가 매개 변수를 두 개 가지기 때문이다.  
그리고 method()가 리턴 타입이 있기 때문에 중괄호 {}에는 return문이 있어야 한다.  
~~~
MyFunctionalInterface fi = (x, y) -> {... return 값;}
~~~
만약 중괄호 {}에 return문만 있고, return문 뒤에 연산식이나 메소드 호출이 오는 경우라면 다음과 같이 작성할 수 있다.  
~~~
MyFunctionalInterface fi = (x, y) -> { return x + y;}

 ==

MyFunctionalInterface fi = (x, y) -> x + y;
~~~
~~~
MyFunctionalInterface fi = (x, y) -> { return sum(x, y); }
 
 ==

MyFunctionalInterface fi = (x, y) -> sum(x,y);
~~~
람다식이 대입된 인터페이스 참조 변수는 다음과 같이 method()를 호출할 수 있다.
~~~
int result = fi.method(2, 5);
~~~
~~~
public class MyFunctionalInterfaceEx {
 public static void main(String[] args) {
    MyFunctionalInterface fi;
    
    fi = (x, y) -> {
        int result = x + y;
        return result;
    };    
    sout(fi.method(2, 5)); // 7
    
    fi = (x, y) -> {
        return x + y
    };
    sout(fi.method(2, 5)); // 7
    
    // 리턴문만 있을 경우 중괄호 {}와 return문 생략가능
    fi = (x, y) -> x + y;
    sout(fi.method(2, 5)); // 7
    
    // ""
    fi = (x, y) -> sum(x, y);
    sout(fi.method(2, 5)); // 7
    
 }
}
~~~